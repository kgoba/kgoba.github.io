<!DOCTYPE html>
<html lang="en">
<head>
	<title>Meteosonde tracker by YL3JG</title>

	<meta charset="utf-8" />
	<meta name="viewport" content="width=device-width, initial-scale=1.0">

	<link rel="shortcut icon" type="image/x-icon" href="docs/images/favicon.ico" />

    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.8.0/dist/leaflet.css" integrity="sha512-hoalWLoI8r4UszCkZ5kL8vayOGVae1oxXe/2A4AO6J9+580uKHDO3JdHb7NzwwzK5xr/Fs0W40kiNHxM9vyTtQ==" crossorigin="" />
    <script src="https://unpkg.com/leaflet@1.8.0/dist/leaflet.js" integrity="sha512-BB3hKbKWOc9Ez/TAwyWxNXeoV9c1v6FIeYiBieIWkpLjauysF18NzgR1MBNBXf8/KABdlkX68nAhlwcDFLGPCQ==" crossorigin=""></script>
    <script src="js/paho-mqtt-min.js" type="text/javascript"></script>

	<style>
		html, body {
			height: 100%;
			margin: 0;
		}
		.leaflet-container {
			height: 400px;
			width: 600px;
			max-width: 100%;
			max-height: 100%;
		}
	</style>

	<style>body { padding: 0; margin: 0; } #map { height: 100%; width: 100vw; }</style>
</head>

<body>
    <div id='map'></div>
    <script src="js/tracker.js" type="text/javascript"></script>
    <script>
        const mapCenter = [57.00, 24.00];
        const mapRadiusKm = 500;

        // For teleporting to active site (debugging)
        //const mapCenter = [35.00, -115.00];
        //const mapRadiusKm = 1500;

        const sondeAgeMs = 3 * 60 * 60 * 1000;  // 3 hours in miliseconds
        const sondeColorAscent  = '#0000FF';     // If sonde ascenting - blue
        const sondeColorDescent  = '#FF0000';    // If sonde descenting - red
        const sondeColorAged  = '#FFFF00';       // If no data for sondeAgeMs miliseconds - yellow

        function inRange(point) {
            // return (Math.abs(point[0] - mapCenter[1]) < 20) && (Math.abs(point[1] - mapCenter[0]) < 14);
            return map.distance(mapCenter, [point.lat, point.lon]) < (mapRadiusKm * 1000);
        }

        var map = L.map('map', {closePopupOnClick: false});
        map.setView(mapCenter, 6);
        // map.fitWorld();

        // OpenstreetMaps
        L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
            attribution: '&copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors'
        }).addTo(map);

        // WoldImagery map
        //L.tileLayer('https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}', {
        //        attribution: 'Tiles &copy; Esri &mdash; Source: Esri, i-cubed, USDA, USGS, AEX, GeoEye, Getmapping, Aerogrid, IGN, IGP, UPR-EGP, and the GIS User Community',
        //        minZoom: 0,
        //        maxZoom: 19,
        //}).addTo(map);

        // 'https://api.mapbox.com/styles/v1/{username}/{style_id}/tiles/{tilesize}/{z}/{x}/{y}{@2x}'
        // L.tileLayer('https://api.mapbox.com/styles/v1/{id}/tiles/{z}/{x}/{y}?access_token={accessToken}', {
        //     attribution: 'Map data &copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors, Imagery © <a href="https://www.mapbox.com/">Mapbox</a>',
        //     maxZoom: 18,
        //     id: 'mapbox/outdoors-v11',
        //     tileSize: 512,
        //     zoomOffset: -1,
        //     accessToken: 'pk.eyJ1Ijoia2FybGlzZ28iLCJhIjoiY2wxa251aHg3MDJtZjNwbzZ5bXhieDAxOSJ9.CMjr3LPyI_fWDrR07tJe5Q'
        // }).addTo(map);

        // L.tileLayer('https://api.mapbox.com/styles/v1/{id}/tiles/{z}/{x}/{y}?access_token=pk.eyJ1IjoibWFwYm94IiwiYSI6ImNpejY4NXVycTA2emYycXBndHRqcmZ3N3gifQ.rJcFIG214AriISLbB6B5aw', {
        //     maxZoom: 18,
        //     attribution: 'Map data &copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors, ' +
        //         'Imagery © <a href="https://www.mapbox.com/">Mapbox</a>',
        //     id: 'mapbox/streets-v11',
        //     tileSize: 512,
        //     zoomOffset: -1
        // }).addTo(map);

        // Move the default location of zoom control
        map.zoomControl.setPosition('bottomright');

        // Adding range circle to the map
        L.circle(mapCenter, mapRadiusKm*1000, {fill: false}).addTo(map);

        // Add scale control to the map
        L.control.scale().addTo(map);

        function onLocationFound(e) {
            var radius = e.accuracy / 2;

            // var locationMarker = L.marker(e.latlng).addTo(map)
            //     .bindPopup('You are within ' + radius + ' meters from this point').openPopup();

            var locationCircle = L.circle(e.latlng, radius).addTo(map);
        }

        function onLocationError(e) {
            alert(e.message);
        }

        map.on('locationfound', onLocationFound);
        map.on('locationerror', onLocationError);
        // map.locate({setView: true, maxZoom: 8});

        fetchListeners(function(name, loc) {
            let marker = L.circleMarker([loc.lat, loc.lon], { radius: 6, fillColor: '#008000', fillOpacity: 0.6, color: '#000000', weight: 1 });
            marker.bindTooltip(name);
            marker.addTo(map);
        });

        fetchSites(function(name, loc) {
            let marker = L.circleMarker([loc.lat, loc.lon], { radius: 7, fill: false, color: '#000000', weight: 3 });
            marker.bindTooltip(name);
            marker.addTo(map);
        });

        let ui = {
            addSonde: function(data) {
                let marker = L.circleMarker([data.lat, data.lon], { radius: 9, fillColor: '#FF0000', fillOpacity: 0.6, color: '#000000', weight: 1 });
                if (data.hasOwnProperty('vel_v')) {
                    if (data.vel_v > 0) {
                        marker.setStyle({fillColor: sondeColorAscent});
                    } else {
                        marker.setStyle({fillColor: sondeColorDescent});
                    }
                } else {
                    marker.setStyle({fillColor: sondeColorAged});
                }
                marker.addTo(map);
                // marker.bindPopup(name).openPopup();
                marker.bindTooltip(data.serial); // .openTooltip();
                return marker;
            },
            updateSonde: function(marker, data) {
                marker.setLatLng([data.lat, data.lon]);
                let content = '<b>' + data.serial + '</b>';
                content += '<br/>Alt: ' + data.alt.toFixed(0) + 'm | v_v: ';
                if (data.hasOwnProperty('vel_v')) {
                    content += data.vel_v.toFixed(1);
                    if (data.vel_v > 0) {
                        marker.setStyle({fillColor: sondeColorAscent});
                    } else {
                        marker.setStyle({fillColor: sondeColorDescent});
                    }
                } else {
                    content += '---';
                    marker.setStyle({fillColor: sondeColorAged});
                }
                content += 'm/s | v_h: '
                if (data.hasOwnProperty('vel_h')) {
                    content += data.vel_h.toFixed(1);
                }
                else {
                    content += '---';
                }
                content += 'm/s';
                content += '<br/>RX: ';
                if (data.hasOwnProperty('rssi')) {
                    content += ' ' + data.rssi.toFixed(0) + 'dBm';
                }
                if (data.hasOwnProperty('snr')) {
                    content += ' ' + data.snr.toFixed(0) + 'dB';
                }
                if (data.hasOwnProperty('uploader_callsign')) {
                    content += ' by ' + data.uploader_callsign;
                }
                content += '<br/>Freq: ' + data.frequency.toFixed(2) + 'MHz';
                marker.bindPopup(content);
                // marker.setPopupContent(loc.alt.toFixed(0) + 'm');
                // marker.setTooltipContent(loc.alt.toFixed(0) + 'm');
            },
            addPath: function(pointList) {
                let path = L.polyline(pointList.map(x => [x.lat, x.lon]), {color: '#FF0000', opacity: 0.6})
                path.addTo(map);
                return path;
            },
            updatePath: function(path, loc) {
                path.addLatLng([loc.lat, loc.lon]);
            },
        }
        fetchSondes(ui, mapRadiusKm);
    </script>
</body>
</html>
